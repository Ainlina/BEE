% Inputs to algorithm% L and target% Functions using rsq (square of distance from the origin) simplify setup for radially symmetric casesrsqL = (4*rsq+1).*cos(rsq) + 4*sin(rsq);rsqtarget = cos(rsq);L = @(x,y) rsqL(x.^2+y.^2); % L, in terms of x and y for simplicitytarget = @(x,y) rsqtarget(x.^2+y.^2); % Target function% Initial conditionsvertices = 401; % how many vertices to use to describe the starting polygoncurve = @(t) [sin(t) + 0.3,1.2*cos(t)]; % parameterisation of starting polygoncurveend = 2*pi; % with t from 0 to thismeshscale = 0.05; % Scale of the triangulationconvmult = 0.01; % Mesh generation termination parameter% Iteration behaviourepsilon = 0.000001; % Stop when no point moves further than thismaxmultiplier = 0.01; % Maximum multiplier of descent direction to trymaxmovement = 0.1; % Maximum distance moved in an iterationplotsteps = true; % Do we want to plot each intermediate polygon?% Prepare graphicsfigure;hold on;%graphics_toolkit("gnuplot") % Not neded on MacvL = @(v) L(v(:,1),v(:,2)); % Vectorised L functionvtarget = @(v) target(v(:,1),v(:,2)); % Vectorised target functionboundary = curve(transpose(linspace(0,curveend,vertices))); % List of points forming boundary, with first and last the samefd = { 'l_dpolygon', [], boundary }; % Set up triangulationfh = @(p) ones(size(p,1),1);[p,t] = distmesh( fd, fh, meshscale, [-2,-2; 2,2], boundary, convmult); % Triangulate the polygonedges = [t(:,[1,2]);t(:,[1,3]);t(:,[2,3])]; % Edges represented as pairs of indices of pointsedges = sort(edges,2);[uniqueedges, ~, rowidx] = unique(edges, 'rows'); % Remove duplicate edges, and count how many times each edge occursisboundary = 2-accumarray(rowidx, 1); % Edge is a boundary if it occurred once, but not if it occurred twiceboundaryedges = uniqueedges(logical(isboundary),:); % List of boundary edges as pairs of indices, we will use this to plot the boundarystepcount = 0; % Count number of iterations required to converge% Vector naming:% Vectors with names starting with "tri" are indexed by triangle, ith entry or row gives some property of ith triangle,% whereas those starting with "vertex" are indexed by vertex.% First, second, and third vertex of triangles, we will need this often.% This depends only on the topology, not the geometry, of the triangulation, so we don't need to redo it each loop.trii1 = t(:,1);trii2 = t(:,2);trii3 = t(:,3);distancemoved = Inf; % Initialise this so the loop runs at least once.while distancemoved > epsilon% Plot the boundary as a collection of line segmentsif plotstepsboundaryxys = [p(boundaryedges(:,1),:),p(boundaryedges(:,2),:)];boundaryplotxs = reshape ([boundaryxys(:,[1,3]) nan(rows(boundaryxys),1)]', [], 1);boundaryplotys = reshape ([boundaryxys(:,[2,4]) nan(rows(boundaryxys),1)]', [], 1);% We use NaNs to separate line segments in plot, so that vertices are not spuriously joinedplot(boundaryplotxs,boundaryplotys);endif% Geometry of each triangletrio = p(trii1,:); % Base points of triangles, first verticestrid12 = p(trii2,:) - trio; % Vector from first vertex to second of each triangle, in general tridij is from ith vertex to jthtrid13 = p(trii3,:) - trio;trid23 = trid13 - trid12;triareas = (trid12(:,1).*trid13(:,2) - trid12(:,2) .* trid13(:,1)) / 2; % areas of trianglestricentres = trio + (trid12 + trid13)/3; % centroids of triangles% trihi are altitude vectors towards ith vertex, calculated by standard Cartesian geometrytrih1 = -trid12 - repmat(dot(-trid12,trid23,2)./dot(trid23,trid23,2),1,2) .* trid23;trih2 = -trid23 - repmat(dot(-trid23,-trid13,2)./dot(trid13,trid13,2),1,2) .* -trid13;trih3 = trid13 - repmat(dot(trid13,trid12,2)./dot(trid12,trid12,2),1,2) .* trid12;% Gradients to ith vertex, altitude vectors divided by square of their normgrad1 = trih1 ./ repmat(dot(trih1,trih1,2),1,2);grad2 = trih2 ./ repmat(dot(trih2,trih2,2),1,2);grad3 = trih3 ./ repmat(dot(trih3,trih3,2),1,2);% Contributions to A from dot products of gradients of basis elements% IndicesgradsI = [trii1;trii1;trii1;trii2;trii2;trii2;trii3;trii3;trii3];gradsJ = [trii1;trii2;trii3;trii1;trii2;trii3;trii1;trii2;trii3];% Dot product of gradient of basis elements at ith and jth vertex is tridotgradij tridotgrad11 = dot(grad1,grad1,2);tridotgrad12 = dot(grad1,grad2,2);tridotgrad13 = dot(grad1,grad3,2);tridotgrad22 = dot(grad2,grad2,2);tridotgrad23 = dot(grad2,grad3,2);tridotgrad33 = dot(grad3,grad3,2);% Multiply by areas of triangles, and assemble these in order corresponding to the indices, to deal with all cases.gradsval = [tridotgrad11;tridotgrad12;tridotgrad13;  tridotgrad12;tridotgrad22;tridotgrad23;  tridotgrad13;tridotgrad23;tridotgrad33] .* repmat(triareas,9,1);% Contributions to A from scalar products of basis elementsproductsI = [trii1;trii1;trii2;trii2;trii3;trii3;trii1;trii2;trii3];productsJ = [trii2;trii3;trii1;trii3;trii1;trii2;trii1;trii2;trii3];productsval = [repmat(triareas,6,1)/12;repmat(triareas,3,1)/6]; % area/6 for the same vertex twice, area/12 for distinct vertices% Form sparse stiffness matrix A by accumulating contributions from inner product of gradients and scalar products of basis functionsI = [gradsI;productsI];J = [gradsJ;productsJ];vals = [gradsval;productsval];A = sparse(I,J,vals);% Construct load vectorLloadJ = [trii1;trii2;trii3]; % IndicestriLvals = vL(tricentres); % Calculate L on centroidsLloadvals = repmat([triLvals.*triareas/3],3,1); % multiply by areas, and divide by 3b = accumarray(LloadJ,Lloadvals); % Form load vectorvertexfvals = (A \ b); % Solve linear system, computing values of f at vertices, thus specifying it in S% % Similar formation of load vector to calculate qerrorloadJ = [trii1;trii2;trii3];trifvals = (vertexfvals(trii1) + vertexfvals(trii2) + vertexfvals(trii3) ) / 3; % approximate the values of the solution at the centre of each triangletritargetvals = vtarget(tricentres);trierrorvals = ( trifvals - tritargetvals ); % f-target at triangle centreserrorloadvals = repmat([-2*trierrorvals.*triareas/3],3,1); % times -2 as this is what we need for qqb = accumarray(errorloadJ,errorloadvals); % Form load vector for eqn for qvertexqvals = (A \ qb); % Find q on vertices by solbving linear system; note that stiffness matrix is unchanged; in fact, it is only determined by RHS and triangulation% Now we calculate parts for dJ, note that all contributions are per unit area, so will be multiplied by area when the load vector is assembledvertexerrorvals = vertexfvals - vtarget(p); % f-target at verticestriqvals = (vertexqvals(trii1) + vertexqvals(trii2) + vertexqvals(trii3) ) / 3;% Compute gradients of some functions on each trianglevertexvalstotrigrad = @(vvals) repmat(vvals(trii1),1,2).*grad1 + repmat(vvals(trii2),1,2).*grad2 + repmat(vvals(trii3),1,2).*grad3;% We need to redefine the above every loop, as the geometry changestrigradqs = vertexvalstotrigrad(vertexqvals);trigraderrors = vertexvalstotrigrad(vertexerrorvals);trigradfs = vertexvalstotrigrad(vertexfvals);trigradls = vertexvalstotrigrad(vL(p));% these are the values lagrangianvals = trierrorvals.^2 + dot(trigradfs,trigradqs,2) + ( trifvals - triLvals ) .* triqvals ;lagrangianvalVx1contrib = lagrangianvals .* grad1(:,1);lagrangianvalVx2contrib = lagrangianvals .* grad2(:,1);lagrangianvalVx3contrib = lagrangianvals .* grad3(:,1);lagrangianvalVy1contrib = lagrangianvals .* grad1(:,2);lagrangianvalVy2contrib = lagrangianvals .* grad2(:,2);lagrangianvalVy3contrib = lagrangianvals .* grad3(:,2);trivectodotwithV = -2*repmat(trierrorvals,1,2).*trigraderrors - repmat(triqvals,1,2).*trigradls; % The vector that is dotted with V in the second term, approximated for each triangle% Vi = 1/3 in the middle of a triangle with zi as a vertex, so we use this as an approximation, and aking dot product with a Vx or Vy is just taking first or second component.secondtermVxcontrib = trivectodotwithV(:,1)/3; secondtermVycontrib = trivectodotwithV(:,2)/3;trigradfqcrossterms = trigradfs(:,2).*trigradqs(:,1) + trigradfs(:,1).*trigradqs(:,2); % We need this repeatedly, so compute it separately% Compute cases for dJ contribution from third term in formulathirdtermVx1contrib = 2*grad1(:,1).*trigradqs(:,1).*trigradfs(:,1) + grad1(:,2) .* trigradfqcrossterms;thirdtermVx2contrib = 2*grad2(:,1).*trigradqs(:,1).*trigradfs(:,1) + grad2(:,2) .* trigradfqcrossterms;thirdtermVx3contrib = 2*grad3(:,1).*trigradqs(:,1).*trigradfs(:,1) + grad3(:,2) .* trigradfqcrossterms;thirdtermVy1contrib = 2*grad1(:,2).*trigradqs(:,2).*trigradfs(:,2) + grad1(:,1) .* trigradfqcrossterms;thirdtermVy2contrib = 2*grad2(:,2).*trigradqs(:,2).*trigradfs(:,2) + grad2(:,1) .* trigradfqcrossterms;thirdtermVy3contrib = 2*grad3(:,2).*trigradqs(:,2).*trigradfs(:,2) + grad3(:,1) .* trigradfqcrossterms;% Prepare vectors of dJ for v^xs and v^ysdJloadindices = repmat([trii1;trii2;trii3],3,1);dJxloadvals = [lagrangianvalVx1contrib;lagrangianvalVx2contrib;lagrangianvalVx3contrib;  repmat(secondtermVxcontrib,3,1);    thirdtermVx1contrib;thirdtermVx2contrib;thirdtermVx3contrib].*repmat(triareas,9,1);dJxload = accumarray(dJloadindices,dJxloadvals);dJyloadvals = [lagrangianvalVy1contrib;lagrangianvalVy2contrib;lagrangianvalVy3contrib;  repmat(secondtermVycontrib,3,1);    thirdtermVy1contrib;thirdtermVy2contrib;thirdtermVy3contrib].*repmat(triareas,9,1);dJyload = accumarray(dJloadindices,dJyloadvals);dJxvals = A \ dJxload; % coefs of D1 in SdJyvals = A \ dJyload; % coefs of D2 in SdJ = [dJxvals, dJyvals]; % this is D for each vectordJmaxnorm = max(norm(dJ, 2, "rows"));multiplier = min(maxmovement / dJmaxnorm, maxmultiplier); % Initialise step length multiplier so that largest movement is maxmovement units, and capped at maxmultiplier; this variable will only decrease.stopdistanceoptimisation = false;Jval = Inf; % Initialise so it loops at least oncewhile (stopdistanceoptimisation == false) % Loop for repeated halving of multiplier and evaluating Jnewp = p - multiplier * dJ; % Shift p experimentally to new region so we can compute the new J% The computation proceeds as before to determine the values of f% Triangle geometrytrio = newp(trii1,:);trid12 = newp(trii2,:) - trio;trid13 = newp(trii3,:) - trio;trid23 = trid13 - trid12;triareas = (trid12(:,1).*trid13(:,2) - trid12(:,2) .* trid13(:,1)) / 2;tricentres = trio + (trid12 + trid13)/3;% Note that we have changed the geometry, so we need to re-form Atrih1 = -trid12 - repmat(dot(-trid12,trid23,2)./dot(trid23,trid23,2),1,2) .* trid23;trih2 = -trid23 - repmat(dot(-trid23,-trid13,2)./dot(trid13,trid13,2),1,2) .* -trid13;trih3 = trid13 - repmat(dot(trid13,trid12,2)./dot(trid12,trid12,2),1,2) .* trid12;grad1 = trih1 ./ repmat(dot(trih1,trih1,2),1,2);grad2 = trih2 ./ repmat(dot(trih2,trih2,2),1,2);grad3 = trih3 ./ repmat(dot(trih3,trih3,2),1,2);gradsI = [trii1;trii1;trii1;trii2;trii2;trii2;trii3;trii3;trii3];gradsJ = [trii1;trii2;trii3;trii1;trii2;trii3;trii1;trii2;trii3];tridotgrad11 = dot(grad1,grad1,2);tridotgrad12 = dot(grad1,grad2,2);tridotgrad13 = dot(grad1,grad3,2);tridotgrad22 = dot(grad2,grad2,2);tridotgrad23 = dot(grad2,grad3,2);tridotgrad33 = dot(grad3,grad3,2);gradsval = [tridotgrad11;tridotgrad12;tridotgrad13;tridotgrad12;tridotgrad22;tridotgrad23;tridotgrad13;tridotgrad23;tridotgrad33] .* repmat(triareas,9,1);productsI = [trii1;trii1;trii2;trii2;trii3;trii3;trii1;trii2;trii3];productsJ = [trii2;trii3;trii1;trii3;trii1;trii2;trii1;trii2;trii3];productsval = [repmat(triareas,6,1)/12;repmat(triareas,3,1)/6];I = [gradsI;productsI];J = [gradsJ;productsJ];vals = [gradsval;productsval];A = sparse(I,J,vals);% We also re-form bLloadJ = [trii1;trii2;trii3];triLvals = vL(tricentres);Lloadvals = repmat([triLvals.*triareas/3],3,1);b = accumarray(LloadJ,Lloadvals);vertexfvals = A \ b; % Compute solution on verticestrifvals = (vertexfvals(trii1) + vertexfvals(trii2) + vertexfvals(trii3) ) / 3; % Approximate the values of the solution at the centroid of each triangletritargetvals = vtarget(tricentres); % Now we are working with the new triangles, so we need to recalculate thistrierrorvals = trifvals - tritargetvals; % New errorprevJval = Jval; % Record previous J value so we can compare itJval = sum(trierrorvals.^2 .* triareas); % Compute new J valueif (prevJval < Jval || multiplier == 0) % If we have gotten worse J value, or multiplier is 0 to machine precision, stop  stopdistanceoptimisation = true;endifmultiplier = multiplier / 2; % Halve multiplier so we can try againendwhilep = p - 2*multiplier * dJ; % Shift the vertices, the most recent multiplier was worse, and halved again at the end of the loop; this moves by half as far as the best value founddistancemoved = 2*multiplier*dJmaxnorm; % Record this to decide whether to terminatestepcount = stepcount + 1; % count stepsend% Finally, draw the resulting polygonboundaryxys = [p(boundaryedges(:,1),:),p(boundaryedges(:,2),:)];boundaryplotxs = reshape ([boundaryxys(:,[1,3]) nan(rows(boundaryxys),1)]', [], 1); % using NaNs to separate line segments in plotboundaryplotys = reshape ([boundaryxys(:,[2,4]) nan(rows(boundaryxys),1)]', [], 1); plot(boundaryplotxs,boundaryplotys);Jval % Output the final value of Jstepcount % How many steps taken?